#!/usr/bin/env node

const fs = require('fs-ext');
const path = require('path');
const merge = require('merge');
const stripAnsi = require('strip-ansi');
const Runner = require(path.join(__dirname, '..', 'node_modules', 'arpen', 'src', 'services', 'runner.js'));
const Emailer = require(path.join(__dirname, '..', 'node_modules', 'arpen', 'src', 'services', 'emailer.js'));

let args = process.argv.slice(2);
let pidFile = args.shift();
if (!pidFile || !args.length) {
    console.error('Usage: daemon <pidfile> <server-name> [... <server-name>]');
    process.exit(1);
}

let config, runner, emailer;
try {
    let globalConf = require(path.join(__dirname, '..', 'config', 'global.js'));
    let localConf = require(path.join(__dirname, '..', 'config', 'local.js'));
    config = merge.recursive(true, globalConf, localConf);
    runner = new Runner();
    emailer = new Emailer(config);
} catch (error) {
    console.error(error.message);
    process.exit(1);
}

try {
    fs.accessSync(pidFile, fs.constants.F_OK);
    try {
        fs.accessSync(pidFile, fs.constants.R_OK | fs.constants.W_OK);
    } catch (error) {
        console.error(error.message);
        process.exit(1);
    }
} catch (error) {
    try {
        fs.closeSync(fs.openSync(pidFile, 'w'));
    } catch (error) {
        console.error(error.message);
        process.exit(1);
    }
}
require('daemon')();

let fd;
try {
    fd = fs.openSync(pidFile, 'r+');
} catch (error) {
    console.error(error.message);
    process.exit(1);
}

try {
    fs.flockSync(fd, 'exnb');
} catch (error) {
    process.exit(0);
}

let pidBuffer = Buffer(process.pid.toString() + '\n');
fs.ftruncateSync(fd);
fs.writeSync(fd, pidBuffer, 0, pidBuffer.length, null);

function restart() {
    let maxBufferLength = 10000, buffer = '';
    let proc = runner.spawn('node', [ path.join(__dirname, 'server'), ...args ]);
    proc.cmd.on('data', data => {
        process.stdout.write(data);
        buffer += data.toString();
        if (buffer.length > maxBufferLength)
            buffer = buffer.slice(buffer.length - maxBufferLength);
    });
    proc.promise
        .then(result => {
            if (result.code === 0)
                process.exit(0);

            if (!config.email.daemon.enabled) {
                if (result.code === 200)
                    process.exit(200);

                return setTimeout(() => { restart(); }, 1000);
            }

            return emailer.send({
                    from: config.email.from,
                    to: config.email.daemon.to,
                    subject: '[' + config.project + '] Exit code ' + result.code + ' of ' + args.join(' '),
                    text: stripAnsi(buffer),
                })
                .then(function () {
                    if (result.code === 200)
                        process.exit(200);

                    setTimeout(() => { restart(); }, 1000);
                });
        })
        .catch(error => {
            if (!config.email.daemon.enabled)
                process.exit(1);

            return emailer.send({
                    from: config.email.from,
                    to: config.email.daemon.to,
                    subject: '[' + config.project + '] Failed to start ' + args.join(' '),
                    text: error.message,
                })
                .then(function () {
                    process.exit(1);
                });
        });
}
restart();